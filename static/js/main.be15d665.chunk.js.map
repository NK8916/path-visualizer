{"version":3,"sources":["components/Node/index.js","components/Navbar/index.js","components/maze-algorithms/recursive-division.js","components/maze-algorithms/recursive-division-vertical.js","components/maze-algorithms/recurisive-division-horizontal.js","components/algorithms/queue.js","components/algorithms/bfs.js","components/algorithms/depth-first-search.js","components/algorithms/heap.js","components/algorithms/dijsktras.js","components/algorithms/priority-queue.js","components/algorithms/a-star.js","components/algorithms/best-first-search.js","components/create-grid/index.js","components/Pathvisualizer/index.js","components/algorithms/shortest-path.js","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","row","isStart","isFinish","isWall","onMouseDown","onMouseEnter","onMouseUp","onMouseOut","setRef","extractClassName","ref","className","Component","NavBar","algorithms","mazeAlgorithms","delays","navRef","Navbar","expand","variant","Brand","href","Nav","NavDropdown","title","id","onSelect","map","algorithm","idx","Item","key","eventKey","selectMaze","changespeed","delay","Link","onClick","reset","Button","visualize","recursiveDivision","nodes","horizontal","sourceNode","finishNode","startRow","endRow","startCol","endCol","visitedNodes","y","Math","floor","randomNumber","x","finisNode","node","push","addHorizontalWalls","addVerticalWalls","min","max","random","recursiveDivisionVertical","recursiveDivisionHorizontal","Queue","front","tail","length","value","LinkedList","next","temp","current","prev","console","log","getUnvisitedNeighbors","grid","neighbors","filter","neighbor","isVisited","MinHeap","array","heap","buildHeap","parseInt","siftDown","endIdx","firstParentIdx","swapIdx","secondChildIdx","distance","swap","pop","parentIdx","i","j","dijsktras","unvisitedNodes","getAllUnvisitedNodes","closestNode","remove","Infinity","updateUnvisitedNeighbour","unvisitedNeighbour","getUnvisitedNeighbours","previousNode","PriorityQueue","property","firstChildIdx","siftUp","priorityQueue","getScore","fScore","insert","nodeOne","nodeTwo","x1","y1","x2","y2","abs","createNode","direction","Pathvisualizer","state","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","animationDelay","dragStart","dragTarget","mouseIsPressed","algorithmHeading","boardHeight","boardWidth","bind","handleMouseDown","handleMouseEnter","handleMouseUp","handleAlgo","generateMaze","animateTraversal","animateMaze","changeSpeed","navbarHeight","clientHeight","headingHeight","headingRef","document","documentElement","clientWidth","setState","currentRow","getInitialGrid","removeWall","start","finish","dom","resetGrid","createBoundary","setTimeout","animateWall","visitedNodesInorder","shortestPathNodes","animateShortestPath","queue","enqueue","exploredNodes","isEmpty","dequeueFront","unvisitedNeighbors","nodeString","bfs","get","bestFirstSearch","peek","dequeueRear","depthFirstSearch","aStar","currentNode","pathNodes","unshift","getShortestPathNodes","traverseAlgorithms","element","heading","rowIdx","nodeIdx","handleMouseOut","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.be15d665.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport \"./Node.css\";\r\n\r\nexport class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      row,\r\n      isStart,\r\n      isFinish,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      onMouseOut,\r\n      setRef\r\n    } = this.props;\r\n    const extractClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n    return (\r\n      <td\r\n        ref={setRef}\r\n        className={`node ${extractClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n        onMouseOut={()=>onMouseOut()}\r\n      ></td>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport \"./navbar.css\";\r\nimport { Navbar, NavDropdown, Nav, Button } from \"react-bootstrap\";\r\n\r\nexport class NavBar extends Component {\r\n  render() {\r\n    const { algorithms, mazeAlgorithms ,delays,navRef} = this.props;\r\n    return (\r\n      <Navbar ref={navRef} className=\"navbar\" expand=\"lg\" variant=\"dark\">\r\n        <Navbar.Brand href=\"#home\">Path Visualizer</Navbar.Brand>\r\n        <Nav className=\"mr-auto\">\r\n          <NavDropdown\r\n            title=\"Algorithms\"\r\n            id=\"basic-nav-dropdown\"\r\n            onSelect={this.props.onSelect}\r\n          >\r\n            {algorithms.map((algorithm, idx) => {\r\n              return (\r\n                <NavDropdown.Item\r\n                  key={idx}\r\n                  id={`algorithms-${algorithm}`}\r\n                  eventKey={algorithm}\r\n                >\r\n                  {algorithm}\r\n                </NavDropdown.Item>\r\n              );\r\n            })}\r\n          </NavDropdown>\r\n          <NavDropdown\r\n            title=\"Mazes\"\r\n            id=\"basic-nav-dropdown\"\r\n            onSelect={this.props.selectMaze}\r\n          >\r\n            {mazeAlgorithms.map((algorithm, idx) => {\r\n              return (\r\n                <NavDropdown.Item\r\n                  key={idx}\r\n                  id={`algorithms-${algorithm}`}\r\n                  eventKey={algorithm}\r\n                >\r\n                  {algorithm}\r\n                </NavDropdown.Item>\r\n              );\r\n            })}\r\n          </NavDropdown>\r\n          <NavDropdown\r\n            title=\"Speed\"\r\n            id=\"basic-nav-dropdown\"\r\n            onSelect={this.props.changespeed}\r\n          >\r\n            {delays.map((delay, idx) => {\r\n              return (\r\n                <NavDropdown.Item\r\n                  key={idx}\r\n                  id={`delays-${delay}`}\r\n                  eventKey={delay}\r\n                >\r\n                  {delay}\r\n                </NavDropdown.Item>\r\n              );\r\n            })}\r\n          </NavDropdown>\r\n          <Nav.Link onClick={this.props.reset} eventKey={true}>Clear</Nav.Link>\r\n        </Nav>\r\n\r\n        <Button onClick={this.props.visualize} className=\"visualize-button\">\r\n          Visualize\r\n        </Button>\r\n      </Navbar>\r\n    );\r\n  }\r\n}\r\n","\r\n\r\nexport function recursiveDivision(nodes,horizontal,sourceNode,finishNode, startRow, endRow, startCol, endCol,visitedNodes) {\r\n  if(horizontal){\r\n    if(endRow-startRow<2){\r\n      return\r\n    }\r\n    let y=Math.floor(randomNumber(startCol,endCol)/2)*2\r\n    let x=Math.floor(randomNumber(startRow,endRow)/2)*2+1\r\n    addHorizontalWalls(nodes,startCol,endCol,x,y,sourceNode,finishNode,visitedNodes)\r\n\r\n    if(x-2-startRow>endCol-startCol){\r\n      recursiveDivision(nodes,true,sourceNode,finishNode,startRow,x-2,startCol,endCol,visitedNodes)\r\n    }else{\r\n      recursiveDivision(nodes,false,sourceNode,finishNode,startRow,x-2,startCol,endCol,visitedNodes)\r\n    }\r\n\r\n    if(endRow-(x+2)>endCol-startCol){\r\n      recursiveDivision(nodes,true,sourceNode,finishNode,x+2,endRow,startCol,endCol,visitedNodes)\r\n    }else{\r\n      recursiveDivision(nodes,false,sourceNode,finishNode,x+2,endRow,startCol,endCol,visitedNodes)\r\n    }\r\n   \r\n   \r\n  }else{\r\n    if(endCol-startCol<2){\r\n      return\r\n    }\r\n    let x=Math.floor(randomNumber(startRow,endRow)/2)*2\r\n    let y=Math.floor(randomNumber(startCol,endCol)/2)*2+1\r\n\r\n    addVerticalWalls(nodes,startRow,endRow,x,y,sourceNode,finishNode,visitedNodes)\r\n\r\n    if(endRow-startRow>y-2-startCol){\r\n      recursiveDivision(nodes,true,sourceNode,finishNode,startRow,endRow,startCol,y-2,visitedNodes)\r\n    }else{\r\n      recursiveDivision(nodes,false,sourceNode,finishNode,startRow,endRow,startCol,y-2,visitedNodes)\r\n    }\r\n\r\n    if(endRow-startRow>endCol-(y+2)){\r\n      recursiveDivision(nodes,true,sourceNode,finishNode,startRow,endRow,y+2,endCol,visitedNodes)\r\n    }else{\r\n      recursiveDivision(nodes,false,sourceNode,finishNode,startRow,endRow,y+2,endCol,visitedNodes)\r\n    }\r\n    \r\n    \r\n  }\r\n  \r\n  \r\n}\r\n\r\nfunction addVerticalWalls(nodes,startRow,endRow,x,y,sourceNode,finishNode,visitedNodes){\r\n  for(let node of nodes){\r\n    if(node.row>=startRow-1 && node.row<=endRow+1 && node.col===y && node.row!==x && node!==sourceNode && node!==finishNode){\r\n      visitedNodes.push(node)\r\n    }\r\n  }\r\n}\r\n\r\nfunction addHorizontalWalls(nodes,startCol,endCol,x,y,sourceNode,finisNode,visitedNodes){\r\n  for(let node of nodes){\r\n    if(node.col>=startCol-1 && node.col<=endCol+1 && node.row===x && node.col!==y && node!==sourceNode && node!==finisNode){\r\n        visitedNodes.push(node)\r\n    }\r\n  }\r\n\r\n}\r\n\r\nfunction randomNumber(min,max){\r\n  return Math.floor(Math.random()*(max-min+1)+min)\r\n}\r\n\r\n","\r\n\r\nexport function recursiveDivisionVertical(nodes,horizontal,sourceNode,finishNode, startRow, endRow, startCol, endCol,visitedNodes) {\r\n    if(horizontal){\r\n      if(endRow-startRow<2){\r\n        return\r\n      }\r\n      let y=Math.floor(randomNumber(startCol,endCol)/2)*2\r\n      let x=Math.floor(randomNumber(startRow,endRow)/2)*2+1\r\n      addHorizontalWalls(nodes,startCol,endCol,x,y,sourceNode,finishNode,visitedNodes)\r\n  \r\n      if(x-2-startRow>endCol-startCol){\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,startRow,x-2,startCol,endCol,visitedNodes)\r\n      }else{\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,startRow,x-2,startCol,endCol,visitedNodes)\r\n      }\r\n  \r\n      if(endRow-(x+2)>endCol-startCol){\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,x+2,endRow,startCol,endCol,visitedNodes)\r\n      }else{\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,x+2,endRow,startCol,endCol,visitedNodes)\r\n      }\r\n     \r\n     \r\n    }else{\r\n      if(endCol-startCol<2){\r\n        return\r\n      }\r\n      let x=Math.floor(randomNumber(startRow,endRow)/2)*2\r\n      let y=Math.floor(randomNumber(startCol,endCol)/2)*2+1\r\n  \r\n      addVerticalWalls(nodes,startRow,endRow,x,y,sourceNode,finishNode,visitedNodes)\r\n  \r\n      if(endRow-startRow>y-2-startCol){\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,startRow,endRow,startCol,y-2,visitedNodes)\r\n      }else{\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,startRow,endRow,startCol,y-2,visitedNodes)\r\n      }\r\n  \r\n      if(endRow-startRow>endCol-(y+2)){\r\n        recursiveDivisionVertical(nodes,true,sourceNode,finishNode,startRow,endRow,y+2,endCol,visitedNodes)\r\n      }else{\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,startRow,endRow,y+2,endCol,visitedNodes)\r\n      }\r\n      \r\n      \r\n    }\r\n    \r\n    \r\n  }\r\n  \r\n  function addVerticalWalls(nodes,startRow,endRow,x,y,sourceNode,finishNode,visitedNodes){\r\n    for(let node of nodes){\r\n      if(node.row>=startRow-1 && node.row<=endRow+1 && node.col===y && node.row!==x && node!==sourceNode && node!==finishNode){\r\n        visitedNodes.push(node)\r\n      }\r\n    }\r\n  }\r\n  \r\n  function addHorizontalWalls(nodes,startCol,endCol,x,y,sourceNode,finisNode,visitedNodes){\r\n    for(let node of nodes){\r\n      if(node.col>=startCol-1 && node.col<=endCol+1 && node.row===x && node.col!==y && node!==sourceNode && node!==finisNode){\r\n          visitedNodes.push(node)\r\n      }\r\n    }\r\n  \r\n  }\r\n  \r\n  function randomNumber(min,max){\r\n    return Math.floor(Math.random()*(max-min+1)+min)\r\n  }\r\n  \r\n  ","\r\n\r\nexport function recursiveDivisionHorizontal(nodes,horizontal,sourceNode,finishNode, startRow, endRow, startCol, endCol,visitedNodes) {\r\n    if(horizontal){\r\n      if(endRow-startRow<2){\r\n        return\r\n      }\r\n      let y=Math.floor(randomNumber(startCol,endCol)/2)*2\r\n      let x=Math.floor(randomNumber(startRow,endRow)/2)*2+1\r\n      addHorizontalWalls(nodes,startCol,endCol,x,y,sourceNode,finishNode,visitedNodes)\r\n  \r\n      if(x-2-startRow>endCol-startCol){\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,startRow,x-2,startCol,endCol,visitedNodes)\r\n      }else{\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,startRow,x-2,startCol,endCol,visitedNodes)\r\n      }\r\n  \r\n      if(endRow-(x+2)>endCol-startCol){\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,x+2,endRow,startCol,endCol,visitedNodes)\r\n      }else{\r\n        recursiveDivisionHorizontal(nodes,false,sourceNode,finishNode,x+2,endRow,startCol,endCol,visitedNodes)\r\n      }\r\n     \r\n     \r\n    }else{\r\n      if(endCol-startCol<2){\r\n        return\r\n      }\r\n      let x=Math.floor(randomNumber(startRow,endRow)/2)*2\r\n      let y=Math.floor(randomNumber(startCol,endCol)/2)*2+1\r\n  \r\n      addVerticalWalls(nodes,startRow,endRow,x,y,sourceNode,finishNode,visitedNodes)\r\n  \r\n      if(endRow-startRow>y-2-startCol){\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,startRow,endRow,startCol,y-2,visitedNodes)\r\n      }else{\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,startRow,endRow,startCol,y-2,visitedNodes)\r\n      }\r\n  \r\n      if(endRow-startRow>endCol-(y+2)){\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,startRow,endRow,y+2,endCol,visitedNodes)\r\n      }else{\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,startRow,endRow,y+2,endCol,visitedNodes)\r\n      }\r\n      \r\n      \r\n    }\r\n    \r\n    \r\n  }\r\n  \r\n  function addVerticalWalls(nodes,startRow,endRow,x,y,sourceNode,finishNode,visitedNodes){\r\n    for(let node of nodes){\r\n      if(node.row>=startRow-1 && node.row<=endRow+1 && node.col===y && node.row!==x && node!==sourceNode && node!==finishNode){\r\n        visitedNodes.push(node)\r\n      }\r\n    }\r\n  }\r\n  \r\n  function addHorizontalWalls(nodes,startCol,endCol,x,y,sourceNode,finisNode,visitedNodes){\r\n    for(let node of nodes){\r\n      if(node.col>=startCol-1 && node.col<=endCol+1 && node.row===x && node.col!==y && node!==sourceNode && node!==finisNode){\r\n          visitedNodes.push(node)\r\n      }\r\n    }\r\n  \r\n  }\r\n  \r\n  function randomNumber(min,max){\r\n    return Math.floor(Math.random()*(max-min+1)+min)\r\n  }\r\n  \r\n  ","export class Queue {\r\n  constructor() {\r\n    this.front = null;\r\n    this.tail = null;\r\n    this.length = 0;\r\n  }\r\n  enqueue(value) {\r\n    const node = new LinkedList(value);\r\n    if (!this.front) {\r\n      this.front = node;\r\n      this.tail = node;\r\n    } else {\r\n      this.tail.next = node;\r\n      this.tail = node;\r\n    }\r\n    this.length += 1;\r\n  }\r\n\r\n  dequeueFront() {\r\n    if (this.front) {\r\n      let temp = this.front;\r\n      this.front = this.front.next;\r\n      temp.next = null;\r\n      this.length -= 1;\r\n      return temp.value;\r\n    }\r\n  }\r\n\r\n  dequeueRear() {\r\n    if (this.front) {\r\n      let current = this.front;\r\n      let prev = null;\r\n      console.log(this.front, current);\r\n\r\n      while (current !== null) {\r\n        prev = current;\r\n        current = current.next;\r\n      }\r\n\r\n      let temp = this.tail;\r\n      prev.next = null;\r\n      this.tail = prev;\r\n      this.length -= 1;\r\n      return temp.value;\r\n    }\r\n  }\r\n\r\n  peek() {\r\n    if (this.front) {\r\n      return this.front.value;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.length === 0;\r\n  }\r\n}\r\n\r\nclass LinkedList {\r\n  constructor(value) {\r\n    this.value = value;\r\n    this.next = null;\r\n  }\r\n}\r\n","import { Queue } from \"./queue\";\r\n\r\nexport function bfs(grid, sourceNode, finishNode) {\r\n  console.log(\"In bfs\");\r\n  const visitedNodes = [];\r\n  let queue = new Queue();\r\n  queue.enqueue(sourceNode);\r\n  let sourceString = `${sourceNode.row}-${sourceNode.col}`;\r\n  let exploredNodes = {};\r\n  exploredNodes[sourceString] = true;\r\n  while (!queue.isEmpty()) {\r\n    const node = queue.dequeueFront();\r\n    if (node.isWall) continue;\r\n\r\n    node.isVisited = true;\r\n    visitedNodes.push(node);\r\n    if (node === finishNode) return visitedNodes;\r\n\r\n    let unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      let nodeString = `${neighbor.row}-${neighbor.col}`;\r\n      if (!exploredNodes[nodeString]) {\r\n        exploredNodes[nodeString] = true;\r\n        neighbor.previousNode = node;\r\n        queue.enqueue(neighbor);\r\n      }\r\n    }\r\n  }\r\n  return visitedNodes;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  let neighbors = [];\r\n  const { row, col } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n","import { Queue } from \"./queue\";\r\nexport function depthFirstSearch(grid, sourceNode, finishNode) {\r\n  console.log(\"In dfs\");\r\n  const visitedNodes = [];\r\n  let queue = new Queue();\r\n  queue.enqueue(sourceNode);\r\n  console.log(queue.peek());\r\n  let sourceString = `${sourceNode.row}-${sourceNode.col}`;\r\n  let exploredNodes = {};\r\n  exploredNodes[sourceString] = true;\r\n  while (!queue.isEmpty()) {\r\n    const node = queue.dequeueRear();\r\n    let nodeString = `${node.row}-${node.col}`;\r\n\r\n    if (node.isWall) continue;\r\n    exploredNodes[nodeString] = true;\r\n    node.isVisited = true;\r\n    visitedNodes.push(node);\r\n    if (node === finishNode) return visitedNodes;\r\n\r\n    let unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      let nodeString = `${neighbor.row}-${neighbor.col}`;\r\n      if (!exploredNodes[nodeString]) {\r\n        neighbor.previousNode = node;\r\n        queue.enqueue(neighbor);\r\n      }\r\n    }\r\n  }\r\n  return visitedNodes;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  let neighbors = [];\r\n  const { row, col } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n","export class MinHeap {\r\n  constructor(array) {\r\n    this.heap = this.buildHeap(array);\r\n  }\r\n\r\n  buildHeap(array) {\r\n    let firstParentIdx = parseInt((array.length - 1) / 2);\r\n    for (let idx = firstParentIdx; idx >= 0; idx--) {\r\n      this.siftDown(idx, array.length - 1, array);\r\n    }\r\n    return array;\r\n  }\r\n\r\n  siftDown(idx, endIdx, heap) {\r\n    let firstParentIdx = idx * 2 + 1;\r\n    let swapIdx = -1;\r\n    while (firstParentIdx <= endIdx) {\r\n      let secondChildIdx = idx * 2 + 2 <= endIdx ? idx * 2 + 2 : -1;\r\n      if (\r\n        secondChildIdx !== -1 &&\r\n        heap[secondChildIdx].distance < heap[firstParentIdx].distance\r\n      ) {\r\n        swapIdx = secondChildIdx;\r\n      } else {\r\n        swapIdx = firstParentIdx;\r\n      }\r\n      if (heap[swapIdx].distance < heap[idx].distance) {\r\n        this.swap(swapIdx, idx, heap);\r\n      } else {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  remove() {\r\n    this.swap(0, this.heap.length - 1, this.heap);\r\n    let value = this.heap.pop();\r\n    this.siftDown(0, this.heap.length - 1, this.heap);\r\n    return value;\r\n  }\r\n\r\n  siftUp(idx, heap) {\r\n    let parentIdx = parseInt((idx - 1) / 2);\r\n    while (idx >= 0 && heap[parentIdx].distance > heap[idx].distance) {\r\n      this.swap(idx, parentIdx, heap);\r\n      idx = parentIdx;\r\n      parentIdx = parseInt(idx - 1) / 2;\r\n    }\r\n  }\r\n\r\n  swap(i, j, array) {\r\n    let temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n}\r\n","import { MinHeap } from \"./heap\";\r\n\r\nexport function dijsktras(grid, sourceNode, finishNode) {\r\n  console.log(\"in dijkstras\");\r\n  let visitedNodes = [];\r\n  sourceNode.distance = 0;\r\n  let unvisitedNodes = getAllUnvisitedNodes(grid);\r\n\r\n  while (unvisitedNodes.length) {\r\n    let heap = new MinHeap(unvisitedNodes);\r\n    let closestNode = heap.remove();\r\n\r\n    if (closestNode.isWall) continue;\r\n\r\n    if (closestNode.distance === Infinity) return visitedNodes;\r\n    closestNode.isVisited = true;\r\n    visitedNodes.push(closestNode);\r\n\r\n    if (closestNode === finishNode) return visitedNodes;\r\n    updateUnvisitedNeighbour(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbour(node, grid) {\r\n  let unvisitedNeighbour = getUnvisitedNeighbours(node, grid);\r\n  for (const neighbor of unvisitedNeighbour) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  let neighbors = [];\r\n  const { row, col } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllUnvisitedNodes(grid) {\r\n  let nodes = [];\r\n  for (let row of grid) {\r\n    for (let node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n\r\n  return nodes;\r\n}\r\n","export class PriorityQueue {\r\n  constructor(property) {\r\n    this.heap = [];\r\n    this.property = property;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  get() {\r\n    return this.remove();\r\n  }\r\n\r\n  siftDown(idx, endIdx, heap) {\r\n    let firstChildIdx = idx * 2 + 1;\r\n    let swapIdx = -1;\r\n    while (firstChildIdx <= endIdx) {\r\n      let secondChildIdx = idx * 2 + 2 <= endIdx ? idx * 2 + 2 : -1;\r\n      if (\r\n        secondChildIdx !== -1 &&\r\n        heap[secondChildIdx][this.property] < heap[firstChildIdx][this.property]\r\n      ) {\r\n        swapIdx = secondChildIdx;\r\n      } else {\r\n        swapIdx = firstChildIdx;\r\n      }\r\n      if (heap[swapIdx][this.property] < heap[idx][this.property]) {\r\n        this.swap(swapIdx, idx, heap);\r\n      } else {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  insert(value) {\r\n    this.heap.push(value);\r\n    this.siftUp(this.heap.length - 1, this.heap);\r\n  }\r\n\r\n  remove() {\r\n    this.swap(0, this.heap.length - 1, this.heap);\r\n    let value = this.heap.pop();\r\n    this.siftDown(0, this.heap.length - 1, this.heap);\r\n    return value;\r\n  }\r\n\r\n  siftUp(idx, heap) {\r\n    let parentIdx = parseInt((idx - 1) / 2);\r\n    while (\r\n      idx > 0 &&\r\n      heap[parentIdx][this.property] > heap[idx][this.property]\r\n    ) {\r\n      this.swap(idx, parentIdx, heap);\r\n      idx = parentIdx;\r\n      parentIdx = parseInt((idx - 1) / 2);\r\n    }\r\n  }\r\n\r\n  swap(i, j, array) {\r\n    let temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n}\r\n","import { PriorityQueue } from \"./priority-queue\";\r\n\r\nexport function aStar(grid, sourceNode, finishNode) {\r\n  let visitedNodes = [];\r\n  sourceNode.distance = 0;\r\n  sourceNode.fScore = getScore(sourceNode, finishNode);\r\n  sourceNode.direction = \"up\";\r\n  let priorityQueue = new PriorityQueue(\"fScore\");\r\n  priorityQueue.insert(sourceNode);\r\n  while (!priorityQueue.isEmpty()) {\r\n    let node = priorityQueue.get();\r\n\r\n    if(node.isWall) continue\r\n    node.isVisited = true;\r\n    visitedNodes.push(node);\r\n\r\n    if (node === finishNode) return visitedNodes;\r\n    updateUnvisitedNeighbour(node, grid, finishNode, priorityQueue);\r\n  }\r\n  return visitedNodes;\r\n}\r\n\r\nfunction updateUnvisitedNeighbour(node, grid, finishNode, priorityQueue) {\r\n  let unvisitedNeighbour = getUnvisitedNeighbours(node, grid);\r\n  for (const neighbor of unvisitedNeighbour) {\r\n    let distance = getScore(node, neighbor);\r\n    if (distance < neighbor.distance) {\r\n      neighbor.previousNode = node;\r\n      neighbor.distance = distance;\r\n      neighbor.fScore = distance + getScore(neighbor, finishNode);\r\n      if (!neighbor.isVisited) {\r\n        priorityQueue.insert(neighbor);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction getScore(nodeOne, nodeTwo) {\r\n  const x1 = nodeOne.row;\r\n  const y1 = nodeOne.col;\r\n  const x2 = nodeTwo.row;\r\n  const y2 = nodeTwo.col;\r\n\r\n  return Math.abs(x1 - x2) + Math.abs(y1 - y2);\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  let neighbors = [];\r\n  const { row, col } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors;\r\n}\r\n","import { PriorityQueue } from \"./priority-queue\";\r\n\r\nexport function bestFirstSearch(grid, sourceNode, finishNode) {\r\n  console.log(\"best first search\");\r\n  let visitedNodes = [];\r\n  sourceNode.distance = 0;\r\n  let priorityQueue = new PriorityQueue(\"distance\");\r\n\r\n  priorityQueue.insert(sourceNode);\r\n\r\n  while (!priorityQueue.isEmpty()) {\r\n    const node = priorityQueue.get();\r\n    if (node.isWall) continue;\r\n    node.isVisited = true;\r\n    visitedNodes.push(node);\r\n\r\n    if (node === finishNode) return visitedNodes;\r\n\r\n    let unvisitedNodes = updateUnvisitedNeighbour(node, grid);\r\n\r\n    for (let neighbor of unvisitedNodes) {\r\n      if (!neighbor.isVisited) {\r\n        neighbor.isVisited = true;\r\n        priorityQueue.insert(neighbor);\r\n      }\r\n    }\r\n  }\r\n\r\n  return visitedNodes;\r\n}\r\n\r\nfunction updateUnvisitedNeighbour(node, grid) {\r\n  let unvisitedNeighbour = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbour) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n\r\n  return unvisitedNeighbour;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  let neighbors = [];\r\n  const { row, col } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n","const createNode = (col, row) => {\r\n    return {\r\n      row,\r\n      col,\r\n      isStart: false,\r\n      isFinish: false,\r\n      direction: null,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      fScore: Infinity,\r\n    };\r\n  };\r\n  \r\n  export const getInitialGrid=(boardHeight,boardWidth)  =>{\r\n    const grid = [];\r\n    for (let row = 0; row < boardHeight; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < boardWidth; col++) {\r\n        currentRow.push(createNode(col, row));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n\r\n  export const resetGrid=(ref,nodes,sourceNode,finishNode,removeWall)=>{\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        let node = nodes[i];\r\n        if(!removeWall && node.isWall){\r\n          continue\r\n        }\r\n        let dom=ref[`node-${node.row}-${node.col}`]\r\n        if(node===sourceNode){\r\n          node.isStart=true\r\n          dom.className=\"node node-start\"\r\n        }\r\n        else if(node===finishNode){\r\n          node.isFinish=true\r\n         \r\n          dom.className=\"node node-finish\"\r\n        }\r\n        else{\r\n          dom.className=\"node\"\r\n        }\r\n         \r\n          node.isVisited=false\r\n          \r\n        }\r\n        \r\n\r\n  }\r\n  ","import React, { Component } from \"react\";\r\nimport { Node } from \"../Node\";\r\nimport { NavBar } from \"../Navbar\";\r\nimport { recursiveDivision } from \"../maze-algorithms/recursive-division\";\r\nimport {recursiveDivisionVertical} from \"../maze-algorithms/recursive-division-vertical\";\r\nimport {recursiveDivisionHorizontal} from '../maze-algorithms/recurisive-division-horizontal';\r\nimport { bfs } from \"../algorithms/bfs\";\r\nimport { depthFirstSearch } from \"../algorithms/depth-first-search\";\r\nimport { dijsktras } from \"../algorithms/dijsktras\";\r\nimport { aStar } from \"../algorithms/a-star\";\r\nimport { bestFirstSearch } from \"../algorithms/best-first-search\";\r\nimport { getShortestPathNodes } from \"../algorithms/shortest-path\";\r\nimport {getInitialGrid,resetGrid} from '../create-grid'\r\nimport \"./Pathvisualizer.css\";\r\n\r\n\r\nexport class Pathvisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      START_NODE_ROW: null,\r\n      START_NODE_COL: null,\r\n      FINISH_NODE_ROW: null,\r\n      FINISH_NODE_COL: null,\r\n      animationDelay:10,\r\n      dragStart: false,\r\n      dragTarget: false,\r\n      mouseIsPressed: false,\r\n      delays:[\"Slow\",\"Average\",\"Fast\"],\r\n      algorithmHeading: \"Pick An Algorithm\",\r\n      algorithm: \"\",\r\n      mazeAlgorithms: [\"Recursive Division\",\"Recursive Division (Vertical)\",\"Recursive Division (Horizontal)\"],\r\n      algorithms: [\r\n        \"Dijsktras\",\r\n        \"Breadth First Search\",\r\n        \"Best First Search\",\r\n        \"Depth First Search\",\r\n        \"A* Algorithm\",\r\n      ],\r\n      boardHeight:null,\r\n      boardWidth:null\r\n    };\r\n    this.visualize = this.visualize.bind(this);\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\r\n    this.handleMouseUp = this.handleMouseUp.bind(this);\r\n    this.handleAlgo = this.handleAlgo.bind(this);\r\n    this.generateMaze = this.generateMaze.bind(this);\r\n    this.reset=this.reset.bind(this)\r\n    this.animateTraversal=this.animateTraversal.bind(this)\r\n    this.animateMaze=this.animateMaze.bind(this)\r\n    this.changeSpeed=this.changeSpeed.bind(this)\r\n  }\r\n  componentDidMount() {\r\n    const navbarHeight=this.navRef.clientHeight;\r\n    const headingHeight=this.headingRef.clientHeight\r\n    let boardHeight=Math.floor((document.documentElement.clientHeight-navbarHeight-headingHeight)/30)\r\n    let boardWidth=Math.floor(document.documentElement.clientWidth/25)\r\n    this.setState({START_NODE_ROW:parseInt(boardHeight/2),START_NODE_COL:parseInt(boardWidth/4)})\r\n    this.setState({FINISH_NODE_ROW:parseInt(boardHeight/2),FINISH_NODE_COL:parseInt(3*boardWidth/4)})\r\n    this.setState({boardHeight,boardWidth})\r\n    const grid = getInitialGrid(boardHeight,boardWidth);\r\n    this.setState({ grid });\r\n  }\r\n  \r\n  changeSpeed(delay){\r\n    console.log(\"Dele\",delay)\r\n    switch(delay){\r\n      case \"Slow\":{\r\n        this.setState({animationDelay:20})\r\n        break\r\n      }\r\n      case \"Average\":{\r\n        this.setState({animationDelay:10})\r\n        break\r\n      }\r\n      case \"Fast\":{\r\n        this.setState({animationDelay:5})\r\n        break\r\n      }\r\n      default:\r\n        this.setState({animationDelay:10})\r\n    }\r\n  }\r\n\r\n\r\n  reset(removeWall){\r\n    const { grid , \r\n      START_NODE_ROW,\r\n      START_NODE_COL,\r\n      FINISH_NODE_ROW,\r\n      FINISH_NODE_COL,\r\n    } = this.state;\r\n    const start = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finish = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let nodes=getAllUnvisitedNodes(grid)\r\n    resetGrid(this,nodes,start,finish,removeWall)\r\n    this.setState({algorithmHeading:\"Pick An Algorithm\"})\r\n  }\r\n\r\n  generateMaze(algorithm) {\r\n    const { grid , \r\n      START_NODE_ROW,\r\n      START_NODE_COL,\r\n      FINISH_NODE_ROW,\r\n      FINISH_NODE_COL,\r\n      boardHeight,\r\n      boardWidth\r\n    } = this.state;\r\n    const start = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finish = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let visitedNodes=[]\r\n   \r\n    let nodes=getAllUnvisitedNodes(grid)\r\n    switch (algorithm) {\r\n      case \"Recursive Division\": {\r\n        this.createBoundary(grid,boardHeight,boardWidth,visitedNodes)\r\n       recursiveDivision(\r\n          nodes,\r\n          false,\r\n          start,\r\n          finish,\r\n          2,\r\n        boardHeight-3,\r\n          2,\r\n          boardWidth-3,\r\n          visitedNodes\r\n        );\r\n      \r\n      \r\n        break;\r\n      }\r\n      case \"Recursive Division (Vertical)\":{\r\n        this.createBoundary(grid,boardHeight,boardWidth,visitedNodes)\r\n        recursiveDivisionVertical(  nodes,\r\n          false,\r\n          start,\r\n          finish,\r\n          2,\r\n        boardHeight-3,\r\n          2,\r\n          boardWidth-3,\r\n          visitedNodes)\r\n        break\r\n      }\r\n      case \"Recursive Division (Horizontal)\":{\r\n        this.createBoundary(grid,boardHeight,boardWidth,visitedNodes)\r\n        recursiveDivisionHorizontal(  nodes,\r\n          true,\r\n          start,\r\n          finish,\r\n          2,\r\n        boardHeight-3,\r\n          2,\r\n          boardWidth-3,\r\n          visitedNodes)\r\n        break\r\n      }\r\n      default:\r\n        this.reset()\r\n    }\r\n\r\n    if(visitedNodes && visitedNodes.length){\r\n          \r\n      this.animateMaze(visitedNodes);\r\n    }\r\n  }\r\n\r\n  createBoundary(grid,boardHeight,boardWidth,visitedNodes){\r\n    for(let row=0;row<boardHeight;row++){\r\n      for(let col=0;col<boardWidth;col++){\r\n        if(row===0 || row===boardHeight-1 || col===0 || col===boardWidth-1){\r\n          visitedNodes.push(grid[row][col])\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  animateMaze(visitedNodes) {\r\n    for (let i = 0; i < visitedNodes.length; i++) {\r\n      setTimeout(() => {\r\n        let node = visitedNodes[i];\r\n        node.isWall=true\r\n        let dom=this[`node-${node.row}-${node.col}`]\r\n        dom.className=\"node node-wall\"\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  handleAlgo(algorithm) {\r\n    switch (algorithm) {\r\n      case \"Breadth First Search\": {\r\n        this.setState({ algorithm: \"Breadth First Search\" });\r\n        this.setState({ algorithmHeading: \"Breadth First Search Algorithm\" });\r\n        break;\r\n      }\r\n      case \"Dijsktras\": {\r\n        this.setState({ algorithm: \"Dijsktras\" });\r\n        this.setState({ algorithmHeading: \"Dijsktras Algorithm\" });\r\n        break;\r\n      }\r\n      case \"Best First Search\": {\r\n        this.setState({ algorithm: \"Best First Search\" });\r\n        this.setState({ algorithmHeading: \"Best First Search Algorithm\" });\r\n        break;\r\n      }\r\n\r\n      case \"Depth First Search\": {\r\n        this.setState({ algorithm: \"Depth First Search\" });\r\n        this.setState({ algorithmHeading: \"Depth First Search Algorithm\" });\r\n        break;\r\n      }\r\n      case \"A* Algorithm\": {\r\n        this.setState({ algorithm: \"A* Algorithm\" });\r\n        this.setState({ algorithmHeading: \"A* Algorithm\" });\r\n        break;\r\n      }\r\n      default:\r\n        this.setState({ algorithm: \"\" });\r\n    }\r\n  }\r\n\r\n  animateWall(row,col){\r\n    let dom=this[`node-${row}-${col}`]\r\n    dom.className=\"node node-wall\"\r\n  }\r\n  \r\n  handleMouseDown(row, col) {\r\n    const {\r\n      grid,\r\n      START_NODE_ROW,\r\n      START_NODE_COL,\r\n      FINISH_NODE_ROW,\r\n      FINISH_NODE_COL,\r\n    } = this.state;\r\n    if (row === START_NODE_ROW && col === START_NODE_COL) {\r\n      this.setState({ dragStart: true});\r\n    } else if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\r\n      this.setState({ dragTarget: true });\r\n    } else {\r\n      grid[row][col].isWall=!grid[row][col].isWall\r\n      this.animateWall(row,col)\r\n      this.setState({mouseIsPressed:true})\r\n    }\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    const { grid,dragStart, dragTarget, mouseIsPressed } = this.state;\r\n    if (dragStart) {\r\n      this.setState({ START_NODE_ROW: row, START_NODE_COL: col });\r\n    } \r\n    else if (dragTarget) {\r\n      this.setState({ FINISH_NODE_ROW: row, FINISH_NODE_COL: col });\r\n    } \r\n    else if (mouseIsPressed ) {\r\n      grid[row][col].isWall=!grid[row][col].isWall\r\n      this.animateWall(row,col)\r\n      this.setState({mouseIsPressed:true})\r\n    }\r\n  }\r\n\r\n  handleMouseOut(){\r\n    this.setState({\r\n      mouseIsPressed: false,\r\n    });\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({\r\n      mouseIsPressed: false,\r\n      dragStart: false,\r\n      dragTarget: false,\r\n    });\r\n  }\r\n\r\n  animateTraversal(visitedNodesInorder, shortestPathNodes) {\r\n    const {animationDelay}=this.state\r\n    for (let i = 0; i <= visitedNodesInorder.length; i++) {\r\n      if (i === visitedNodesInorder.length) {\r\n        if(!shortestPathNodes.length){\r\n          return\r\n        }\r\n        setTimeout(() => {\r\n          this.animateShortestPath(shortestPathNodes);\r\n        }, animationDelay * i);\r\n\r\n        return;\r\n      }\r\n\r\n      setTimeout(() => {\r\n        let node = visitedNodesInorder[i];\r\n        let dom=this[`node-${node.row}-${node.col}`]\r\n        dom.className=\"node node-visited\"\r\n      }, animationDelay * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(shortestPathNodes) {\r\n    const {animationDelay}=this.state\r\n    for (let i = 0; i < shortestPathNodes.length; i++) {\r\n      setTimeout(() => {\r\n        let node = shortestPathNodes[i];\r\n        let dom=this[`node-${node.row}-${node.col}`]\r\n        dom.className=\"node shortest-path-node\"\r\n      }, animationDelay*5 * i);\r\n    }\r\n  }\r\n\r\n  traverseAlgorithms(algorithm) {\r\n    let visitedNodesInorder = [];\r\n    const {\r\n      grid,\r\n      START_NODE_ROW,\r\n      START_NODE_COL,\r\n      FINISH_NODE_ROW,\r\n      FINISH_NODE_COL,\r\n    } = this.state;\r\n    const start = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finish = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n\r\n    switch (algorithm) {\r\n      case \"Dijsktras\": {\r\n        visitedNodesInorder = dijsktras(grid, start, finish);\r\n        break;\r\n      }\r\n      case \"Breadth First Search\": {\r\n        visitedNodesInorder = bfs(grid, start, finish);\r\n        break;\r\n      }\r\n\r\n      case \"Best First Search\": {\r\n        visitedNodesInorder = bestFirstSearch(grid, start, finish);\r\n        break;\r\n      }\r\n\r\n      case \"Depth First Search\": {\r\n        visitedNodesInorder = depthFirstSearch(grid, start, finish);\r\n        break;\r\n      }\r\n      case \"A* Algorithm\": {\r\n        visitedNodesInorder = aStar(grid, start, finish);\r\n        break;\r\n      }\r\n      default:\r\n        this.setState({ algorithmHeading: \"Pick An Algorithm\" });\r\n    }\r\n    const shortestPathNodes = getShortestPathNodes(finish);\r\n\r\n    return { visitedNodesInorder, shortestPathNodes };\r\n  }\r\n\r\n  \r\n\r\n  visualize() {\r\n    const { algorithm } = this.state;\r\n    if(algorithm!==\"\"){\r\n      this.reset(false)\r\n      const { visitedNodesInorder, shortestPathNodes } = this.traverseAlgorithms(\r\n        algorithm\r\n      );\r\n    \r\n        this.animateTraversal(visitedNodesInorder, shortestPathNodes);\r\n    }\r\n   \r\n    \r\n  }\r\n  render() {\r\n    const { grid, mouseIsPressed,animationDelay } = this.state;\r\n    return (\r\n      <>\r\n        <NavBar\r\n          navRef={element=>{this.navRef=element}}\r\n          reset={this.reset}\r\n          onSelect={this.handleAlgo}\r\n          selectMaze={this.generateMaze}\r\n          visualize={this.visualize}\r\n          changespeed={this.changeSpeed}\r\n          animationDelay={animationDelay}\r\n          delays={this.state.delays}\r\n          algorithms={this.state.algorithms}\r\n          mazeAlgorithms={this.state.mazeAlgorithms}\r\n          heading={this.state.algorithmHeading}\r\n        ></NavBar>\r\n        <h3 ref={element=>{this.headingRef=element}} className=\"text-center\">{this.state.algorithmHeading}</h3>\r\n        <table className={\"board\"}>\r\n          <tbody>\r\n            {grid.map((row, rowIdx) => {\r\n              return (\r\n                <tr key={rowIdx}>\r\n                  {row.map((node, nodeIdx) => {\r\n                    const { col, row, isWall } = node;\r\n                    return (\r\n                      <Node\r\n                        key={nodeIdx}\r\n                        setRef={(node)=>{ this[`node-${row}-${col}`]=node}}\r\n                        isStart={\r\n                          row === this.state.START_NODE_ROW &&\r\n                          col === this.state.START_NODE_COL\r\n                        }\r\n                        isFinish={\r\n                          row === this.state.FINISH_NODE_ROW &&\r\n                          col === this.state.FINISH_NODE_COL\r\n                        }\r\n                        isWall={isWall}\r\n                        mouseIsPressed={mouseIsPressed}\r\n                        onMouseDown={(row, col) =>\r\n                          this.handleMouseDown(row, col)\r\n                        }\r\n                        onMouseEnter={(row, col) =>\r\n                          this.handleMouseEnter(row, col)\r\n                        }\r\n                        onMouseUp={() => {\r\n                          this.handleMouseUp();\r\n                        }}\r\n                        onMouseOut={()=>{\r\n                          this.handleMouseOut()\r\n                        }}\r\n                        col={col}\r\n                        row={row}\r\n                      ></Node>\r\n                    );\r\n                  })}\r\n                </tr>\r\n              );\r\n            })}\r\n          </tbody>\r\n        </table>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\n\r\nfunction getAllUnvisitedNodes(grid) {\r\n  let nodes = [];\r\n  for (let row of grid) {\r\n    for (let node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n\r\n  return nodes;\r\n}\r\n","export function getShortestPathNodes(finishNode) {\r\n  let currentNode = finishNode;\r\n  let pathNodes = [];\r\n  while (currentNode != null) {\r\n    pathNodes.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return pathNodes;\r\n}\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\n\r\nimport { Pathvisualizer } from \"./components/Pathvisualizer\";\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Pathvisualizer></Pathvisualizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}