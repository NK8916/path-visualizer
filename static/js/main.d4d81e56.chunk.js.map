{"version":3,"sources":["components/Node/index.js","components/Navbar/index.js","components/maze-algorithms/recursive-division.js","components/maze-algorithms/recursive-division-vertical.js","components/maze-algorithms/recurisive-division-horizontal.js","components/algorithms/queue.js","components/algorithms/bfs.js","components/algorithms/depth-first-search.js","components/algorithms/heap.js","components/algorithms/dijsktras.js","components/algorithms/priority-queue.js","components/algorithms/a-star.js","components/algorithms/best-first-search.js","components/create-grid/index.js","components/Pathvisualizer/index.js","components/algorithms/shortest-path.js","App.js","serviceWorker.js","index.js"],"names":["Node","this","props","col","row","isStart","isFinish","isWall","onMouseDown","onMouseEnter","onMouseUp","onMouseOut","setRef","extractClassName","ref","className","Component","NavBar","algorithms","mazeAlgorithms","delays","navRef","animationDelay","Navbar","expand","variant","Brand","href","Nav","NavDropdown","title","id","onSelect","map","algorithm","idx","Item","key","eventKey","selectMaze","changespeed","Object","keys","delay","Link","onClick","reset","Button","visualize","recursiveDivision","nodes","horizontal","sourceNode","finishNode","startRow","endRow","startCol","endCol","visitedNodes","y","Math","floor","randomNumber","x","finisNode","node","push","addHorizontalWalls","addVerticalWalls","min","max","random","recursiveDivisionVertical","recursiveDivisionHorizontal","Queue","front","tail","length","value","LinkedList","next","temp","current","prev","console","log","getUnvisitedNeighbors","grid","neighbors","filter","neighbor","isVisited","MinHeap","array","heap","buildHeap","parseInt","siftDown","endIdx","firstParentIdx","swapIdx","secondChildIdx","distance","swap","pop","parentIdx","i","j","dijsktras","unvisitedNodes","getAllUnvisitedNodes","closestNode","remove","Infinity","updateUnvisitedNeighbour","unvisitedNeighbour","getUnvisitedNeighbours","previousNode","PriorityQueue","property","firstChildIdx","siftUp","priorityQueue","getScore","fScore","insert","nodeOne","nodeTwo","x1","y1","x2","y2","abs","createNode","direction","Pathvisualizer","state","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","dragStart","dragTarget","mouseIsPressed","slow","average","fast","algorithmHeading","boardHeight","boardWidth","bind","handleMouseDown","handleMouseEnter","handleMouseUp","handleAlgo","generateMaze","animateTraversal","animateMaze","navbarHeight","clientHeight","headingHeight","headingRef","document","documentElement","clientWidth","setState","currentRow","getInitialGrid","removeWall","start","finish","dom","resetGrid","createBoundary","setTimeout","animateWall","visitedNodesInorder","shortestPathNodes","animateShortestPath","queue","enqueue","exploredNodes","isEmpty","dequeueFront","unvisitedNeighbors","nodeString","bfs","get","bestFirstSearch","peek","dequeueRear","depthFirstSearch","aStar","currentNode","pathNodes","unshift","getShortestPathNodes","traverseAlgorithms","element","heading","rowIdx","nodeIdx","handleMouseOut","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.d4d81e56.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport \"./Node.css\";\r\n\r\nexport class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      row,\r\n      isStart,\r\n      isFinish,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      onMouseOut,\r\n      setRef\r\n    } = this.props;\r\n    const extractClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n    return (\r\n      <td\r\n        ref={setRef}\r\n        className={`node ${extractClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n        onMouseOut={()=>onMouseOut()}\r\n      ></td>\r\n    );\r\n  }\r\n}\r\n","import React, { Component } from \"react\";\r\nimport \"./navbar.css\";\r\nimport { Navbar, NavDropdown, Nav, Button } from \"react-bootstrap\";\r\n\r\nexport class NavBar extends Component {\r\n  render() {\r\n    const { algorithms, mazeAlgorithms ,delays,navRef,animationDelay} = this.props;\r\n    return (\r\n      <Navbar ref={navRef} className=\"navbar\" expand=\"lg\" variant=\"dark\">\r\n        <Navbar.Brand href=\"#home\">Path Visualizer</Navbar.Brand>\r\n        <Nav className=\"mr-auto\">\r\n          <NavDropdown\r\n            title=\"Algorithms\"\r\n            id=\"basic-nav-dropdown\"\r\n            onSelect={this.props.onSelect}\r\n          >\r\n            {algorithms.map((algorithm, idx) => {\r\n              return (\r\n                <NavDropdown.Item\r\n                  key={idx}\r\n                  id={`algorithms-${algorithm}`}\r\n                  eventKey={algorithm}\r\n                >\r\n                  {algorithm}\r\n                </NavDropdown.Item>\r\n              );\r\n            })}\r\n          </NavDropdown>\r\n          <NavDropdown\r\n            title=\"Mazes\"\r\n            id=\"basic-nav-dropdown\"\r\n            onSelect={this.props.selectMaze}\r\n          >\r\n            {mazeAlgorithms.map((algorithm, idx) => {\r\n              return (\r\n                <NavDropdown.Item\r\n                  key={idx}\r\n                  id={`algorithms-${algorithm}`}\r\n                  eventKey={algorithm}\r\n                >\r\n                  {algorithm}\r\n                </NavDropdown.Item>\r\n              );\r\n            })}\r\n          </NavDropdown>\r\n          <NavDropdown\r\n            title=\"Speed\"\r\n            id=\"basic-nav-dropdown\"\r\n            onSelect={this.props.changespeed}\r\n          >\r\n            {Object.keys(delays).map((delay, idx) => {\r\n              return (\r\n                <NavDropdown.Item\r\n                  key={idx}\r\n                  id={`delays-${delay}`}\r\n                  eventKey={delay}\r\n                >\r\n                  {delay}\r\n                </NavDropdown.Item>\r\n              );\r\n            })}\r\n          </NavDropdown>\r\n          <Nav.Link onClick={this.props.reset} eventKey={true}>Clear</Nav.Link>\r\n        </Nav>\r\n\r\n        <Button onClick={this.props.visualize} className=\"visualize-button\">\r\n          Visualize\r\n        </Button>\r\n      </Navbar>\r\n    );\r\n  }\r\n}\r\n","\r\n\r\nexport function recursiveDivision(nodes,horizontal,sourceNode,finishNode, startRow, endRow, startCol, endCol,visitedNodes) {\r\n  if(horizontal){\r\n    if(endRow-startRow<2){\r\n      return\r\n    }\r\n    let y=Math.floor(randomNumber(startCol,endCol)/2)*2\r\n    let x=Math.floor(randomNumber(startRow,endRow)/2)*2+1\r\n    addHorizontalWalls(nodes,startCol,endCol,x,y,sourceNode,finishNode,visitedNodes)\r\n\r\n    if(x-2-startRow>endCol-startCol){\r\n      recursiveDivision(nodes,true,sourceNode,finishNode,startRow,x-2,startCol,endCol,visitedNodes)\r\n    }else{\r\n      recursiveDivision(nodes,false,sourceNode,finishNode,startRow,x-2,startCol,endCol,visitedNodes)\r\n    }\r\n\r\n    if(endRow-(x+2)>endCol-startCol){\r\n      recursiveDivision(nodes,true,sourceNode,finishNode,x+2,endRow,startCol,endCol,visitedNodes)\r\n    }else{\r\n      recursiveDivision(nodes,false,sourceNode,finishNode,x+2,endRow,startCol,endCol,visitedNodes)\r\n    }\r\n   \r\n   \r\n  }else{\r\n    if(endCol-startCol<2){\r\n      return\r\n    }\r\n    let x=Math.floor(randomNumber(startRow,endRow)/2)*2\r\n    let y=Math.floor(randomNumber(startCol,endCol)/2)*2+1\r\n\r\n    addVerticalWalls(nodes,startRow,endRow,x,y,sourceNode,finishNode,visitedNodes)\r\n\r\n    if(endRow-startRow>y-2-startCol){\r\n      recursiveDivision(nodes,true,sourceNode,finishNode,startRow,endRow,startCol,y-2,visitedNodes)\r\n    }else{\r\n      recursiveDivision(nodes,false,sourceNode,finishNode,startRow,endRow,startCol,y-2,visitedNodes)\r\n    }\r\n\r\n    if(endRow-startRow>endCol-(y+2)){\r\n      recursiveDivision(nodes,true,sourceNode,finishNode,startRow,endRow,y+2,endCol,visitedNodes)\r\n    }else{\r\n      recursiveDivision(nodes,false,sourceNode,finishNode,startRow,endRow,y+2,endCol,visitedNodes)\r\n    }\r\n    \r\n    \r\n  }\r\n  \r\n  \r\n}\r\n\r\nfunction addVerticalWalls(nodes,startRow,endRow,x,y,sourceNode,finishNode,visitedNodes){\r\n  for(let node of nodes){\r\n    if(node.row>=startRow-1 && node.row<=endRow+1 && node.col===y && node.row!==x && node!==sourceNode && node!==finishNode){\r\n      visitedNodes.push(node)\r\n    }\r\n  }\r\n}\r\n\r\nfunction addHorizontalWalls(nodes,startCol,endCol,x,y,sourceNode,finisNode,visitedNodes){\r\n  for(let node of nodes){\r\n    if(node.col>=startCol-1 && node.col<=endCol+1 && node.row===x && node.col!==y && node!==sourceNode && node!==finisNode){\r\n        visitedNodes.push(node)\r\n    }\r\n  }\r\n\r\n}\r\n\r\nfunction randomNumber(min,max){\r\n  return Math.floor(Math.random()*(max-min+1)+min)\r\n}\r\n\r\n","\r\n\r\nexport function recursiveDivisionVertical(nodes,horizontal,sourceNode,finishNode, startRow, endRow, startCol, endCol,visitedNodes) {\r\n    if(horizontal){\r\n      if(endRow-startRow<2){\r\n        return\r\n      }\r\n      let y=Math.floor(randomNumber(startCol,endCol)/2)*2\r\n      let x=Math.floor(randomNumber(startRow,endRow)/2)*2+1\r\n      addHorizontalWalls(nodes,startCol,endCol,x,y,sourceNode,finishNode,visitedNodes)\r\n  \r\n      if(x-2-startRow>endCol-startCol){\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,startRow,x-2,startCol,endCol,visitedNodes)\r\n      }else{\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,startRow,x-2,startCol,endCol,visitedNodes)\r\n      }\r\n  \r\n      if(endRow-(x+2)>endCol-startCol){\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,x+2,endRow,startCol,endCol,visitedNodes)\r\n      }else{\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,x+2,endRow,startCol,endCol,visitedNodes)\r\n      }\r\n     \r\n     \r\n    }else{\r\n      if(endCol-startCol<2){\r\n        return\r\n      }\r\n      let x=Math.floor(randomNumber(startRow,endRow)/2)*2\r\n      let y=Math.floor(randomNumber(startCol,endCol)/2)*2+1\r\n  \r\n      addVerticalWalls(nodes,startRow,endRow,x,y,sourceNode,finishNode,visitedNodes)\r\n  \r\n      if(endRow-startRow>y-2-startCol){\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,startRow,endRow,startCol,y-2,visitedNodes)\r\n      }else{\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,startRow,endRow,startCol,y-2,visitedNodes)\r\n      }\r\n  \r\n      if(endRow-startRow>endCol-(y+2)){\r\n        recursiveDivisionVertical(nodes,true,sourceNode,finishNode,startRow,endRow,y+2,endCol,visitedNodes)\r\n      }else{\r\n        recursiveDivisionVertical(nodes,false,sourceNode,finishNode,startRow,endRow,y+2,endCol,visitedNodes)\r\n      }\r\n      \r\n      \r\n    }\r\n    \r\n    \r\n  }\r\n  \r\n  function addVerticalWalls(nodes,startRow,endRow,x,y,sourceNode,finishNode,visitedNodes){\r\n    for(let node of nodes){\r\n      if(node.row>=startRow-1 && node.row<=endRow+1 && node.col===y && node.row!==x && node!==sourceNode && node!==finishNode){\r\n        visitedNodes.push(node)\r\n      }\r\n    }\r\n  }\r\n  \r\n  function addHorizontalWalls(nodes,startCol,endCol,x,y,sourceNode,finisNode,visitedNodes){\r\n    for(let node of nodes){\r\n      if(node.col>=startCol-1 && node.col<=endCol+1 && node.row===x && node.col!==y && node!==sourceNode && node!==finisNode){\r\n          visitedNodes.push(node)\r\n      }\r\n    }\r\n  \r\n  }\r\n  \r\n  function randomNumber(min,max){\r\n    return Math.floor(Math.random()*(max-min+1)+min)\r\n  }\r\n  \r\n  ","\r\n\r\nexport function recursiveDivisionHorizontal(nodes,horizontal,sourceNode,finishNode, startRow, endRow, startCol, endCol,visitedNodes) {\r\n    if(horizontal){\r\n      if(endRow-startRow<2){\r\n        return\r\n      }\r\n      let y=Math.floor(randomNumber(startCol,endCol)/2)*2\r\n      let x=Math.floor(randomNumber(startRow,endRow)/2)*2+1\r\n      addHorizontalWalls(nodes,startCol,endCol,x,y,sourceNode,finishNode,visitedNodes)\r\n  \r\n      if(x-2-startRow>endCol-startCol){\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,startRow,x-2,startCol,endCol,visitedNodes)\r\n      }else{\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,startRow,x-2,startCol,endCol,visitedNodes)\r\n      }\r\n  \r\n      if(endRow-(x+2)>endCol-startCol){\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,x+2,endRow,startCol,endCol,visitedNodes)\r\n      }else{\r\n        recursiveDivisionHorizontal(nodes,false,sourceNode,finishNode,x+2,endRow,startCol,endCol,visitedNodes)\r\n      }\r\n     \r\n     \r\n    }else{\r\n      if(endCol-startCol<2){\r\n        return\r\n      }\r\n      let x=Math.floor(randomNumber(startRow,endRow)/2)*2\r\n      let y=Math.floor(randomNumber(startCol,endCol)/2)*2+1\r\n  \r\n      addVerticalWalls(nodes,startRow,endRow,x,y,sourceNode,finishNode,visitedNodes)\r\n  \r\n      if(endRow-startRow>y-2-startCol){\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,startRow,endRow,startCol,y-2,visitedNodes)\r\n      }else{\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,startRow,endRow,startCol,y-2,visitedNodes)\r\n      }\r\n  \r\n      if(endRow-startRow>endCol-(y+2)){\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,startRow,endRow,y+2,endCol,visitedNodes)\r\n      }else{\r\n        recursiveDivisionHorizontal(nodes,true,sourceNode,finishNode,startRow,endRow,y+2,endCol,visitedNodes)\r\n      }\r\n      \r\n      \r\n    }\r\n    \r\n    \r\n  }\r\n  \r\n  function addVerticalWalls(nodes,startRow,endRow,x,y,sourceNode,finishNode,visitedNodes){\r\n    for(let node of nodes){\r\n      if(node.row>=startRow-1 && node.row<=endRow+1 && node.col===y && node.row!==x && node!==sourceNode && node!==finishNode){\r\n        visitedNodes.push(node)\r\n      }\r\n    }\r\n  }\r\n  \r\n  function addHorizontalWalls(nodes,startCol,endCol,x,y,sourceNode,finisNode,visitedNodes){\r\n    for(let node of nodes){\r\n      if(node.col>=startCol-1 && node.col<=endCol+1 && node.row===x && node.col!==y && node!==sourceNode && node!==finisNode){\r\n          visitedNodes.push(node)\r\n      }\r\n    }\r\n  \r\n  }\r\n  \r\n  function randomNumber(min,max){\r\n    return Math.floor(Math.random()*(max-min+1)+min)\r\n  }\r\n  \r\n  ","export class Queue {\r\n  constructor() {\r\n    this.front = null;\r\n    this.tail = null;\r\n    this.length = 0;\r\n  }\r\n  enqueue(value) {\r\n    const node = new LinkedList(value);\r\n    if (!this.front) {\r\n      this.front = node;\r\n      this.tail = node;\r\n    } else {\r\n      this.tail.next = node;\r\n      this.tail = node;\r\n    }\r\n    this.length += 1;\r\n  }\r\n\r\n  dequeueFront() {\r\n    if (this.front) {\r\n      let temp = this.front;\r\n      this.front = this.front.next;\r\n      temp.next = null;\r\n      this.length -= 1;\r\n      return temp.value;\r\n    }\r\n  }\r\n\r\n  dequeueRear() {\r\n    if (this.front) {\r\n      let current = this.front;\r\n      let prev = null;\r\n      console.log(this.front, current);\r\n\r\n      while (current !== null) {\r\n        prev = current;\r\n        current = current.next;\r\n      }\r\n\r\n      let temp = this.tail;\r\n      prev.next = null;\r\n      this.tail = prev;\r\n      this.length -= 1;\r\n      return temp.value;\r\n    }\r\n  }\r\n\r\n  peek() {\r\n    if (this.front) {\r\n      return this.front.value;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.length === 0;\r\n  }\r\n}\r\n\r\nclass LinkedList {\r\n  constructor(value) {\r\n    this.value = value;\r\n    this.next = null;\r\n  }\r\n}\r\n","import { Queue } from \"./queue\";\r\n\r\nexport function bfs(grid, sourceNode, finishNode) {\r\n  console.log(\"In bfs\");\r\n  const visitedNodes = [];\r\n  let queue = new Queue();\r\n  queue.enqueue(sourceNode);\r\n  let sourceString = `${sourceNode.row}-${sourceNode.col}`;\r\n  let exploredNodes = {};\r\n  exploredNodes[sourceString] = true;\r\n  while (!queue.isEmpty()) {\r\n    const node = queue.dequeueFront();\r\n    if (node.isWall) continue;\r\n\r\n    node.isVisited = true;\r\n    visitedNodes.push(node);\r\n    if (node === finishNode) return visitedNodes;\r\n\r\n    let unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      let nodeString = `${neighbor.row}-${neighbor.col}`;\r\n      if (!exploredNodes[nodeString]) {\r\n        exploredNodes[nodeString] = true;\r\n        neighbor.previousNode = node;\r\n        queue.enqueue(neighbor);\r\n      }\r\n    }\r\n  }\r\n  return visitedNodes;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  let neighbors = [];\r\n  const { row, col } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n","import { Queue } from \"./queue\";\r\nexport function depthFirstSearch(grid, sourceNode, finishNode) {\r\n  console.log(\"In dfs\");\r\n  const visitedNodes = [];\r\n  let queue = new Queue();\r\n  queue.enqueue(sourceNode);\r\n  console.log(queue.peek());\r\n  let sourceString = `${sourceNode.row}-${sourceNode.col}`;\r\n  let exploredNodes = {};\r\n  exploredNodes[sourceString] = true;\r\n  while (!queue.isEmpty()) {\r\n    const node = queue.dequeueRear();\r\n    let nodeString = `${node.row}-${node.col}`;\r\n\r\n    if (node.isWall) continue;\r\n    exploredNodes[nodeString] = true;\r\n    node.isVisited = true;\r\n    visitedNodes.push(node);\r\n    if (node === finishNode) return visitedNodes;\r\n\r\n    let unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n    for (const neighbor of unvisitedNeighbors) {\r\n      let nodeString = `${neighbor.row}-${neighbor.col}`;\r\n      if (!exploredNodes[nodeString]) {\r\n        neighbor.previousNode = node;\r\n        queue.enqueue(neighbor);\r\n      }\r\n    }\r\n  }\r\n  return visitedNodes;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  let neighbors = [];\r\n  const { row, col } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n","export class MinHeap {\r\n  constructor(array) {\r\n    this.heap = this.buildHeap(array);\r\n  }\r\n\r\n  buildHeap(array) {\r\n    let firstParentIdx = parseInt((array.length - 1) / 2);\r\n    for (let idx = firstParentIdx; idx >= 0; idx--) {\r\n      this.siftDown(idx, array.length - 1, array);\r\n    }\r\n    return array;\r\n  }\r\n\r\n  siftDown(idx, endIdx, heap) {\r\n    let firstParentIdx = idx * 2 + 1;\r\n    let swapIdx = -1;\r\n    while (firstParentIdx <= endIdx) {\r\n      let secondChildIdx = idx * 2 + 2 <= endIdx ? idx * 2 + 2 : -1;\r\n      if (\r\n        secondChildIdx !== -1 &&\r\n        heap[secondChildIdx].distance < heap[firstParentIdx].distance\r\n      ) {\r\n        swapIdx = secondChildIdx;\r\n      } else {\r\n        swapIdx = firstParentIdx;\r\n      }\r\n      if (heap[swapIdx].distance < heap[idx].distance) {\r\n        this.swap(swapIdx, idx, heap);\r\n      } else {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  remove() {\r\n    this.swap(0, this.heap.length - 1, this.heap);\r\n    let value = this.heap.pop();\r\n    this.siftDown(0, this.heap.length - 1, this.heap);\r\n    return value;\r\n  }\r\n\r\n  siftUp(idx, heap) {\r\n    let parentIdx = parseInt((idx - 1) / 2);\r\n    while (idx >= 0 && heap[parentIdx].distance > heap[idx].distance) {\r\n      this.swap(idx, parentIdx, heap);\r\n      idx = parentIdx;\r\n      parentIdx = parseInt(idx - 1) / 2;\r\n    }\r\n  }\r\n\r\n  swap(i, j, array) {\r\n    let temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n}\r\n","import { MinHeap } from \"./heap\";\r\n\r\nexport function dijsktras(grid, sourceNode, finishNode) {\r\n  console.log(\"in dijkstras\");\r\n  let visitedNodes = [];\r\n  sourceNode.distance = 0;\r\n  let unvisitedNodes = getAllUnvisitedNodes(grid);\r\n\r\n  while (unvisitedNodes.length) {\r\n    let heap = new MinHeap(unvisitedNodes);\r\n    let closestNode = heap.remove();\r\n\r\n    if (closestNode.isWall) continue;\r\n\r\n    if (closestNode.distance === Infinity) return visitedNodes;\r\n    closestNode.isVisited = true;\r\n    visitedNodes.push(closestNode);\r\n\r\n    if (closestNode === finishNode) return visitedNodes;\r\n    updateUnvisitedNeighbour(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction updateUnvisitedNeighbour(node, grid) {\r\n  let unvisitedNeighbour = getUnvisitedNeighbours(node, grid);\r\n  for (const neighbor of unvisitedNeighbour) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  let neighbors = [];\r\n  const { row, col } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllUnvisitedNodes(grid) {\r\n  let nodes = [];\r\n  for (let row of grid) {\r\n    for (let node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n\r\n  return nodes;\r\n}\r\n","export class PriorityQueue {\r\n  constructor(property) {\r\n    this.heap = [];\r\n    this.property = property;\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.heap.length === 0;\r\n  }\r\n\r\n  get() {\r\n    return this.remove();\r\n  }\r\n\r\n  siftDown(idx, endIdx, heap) {\r\n    let firstChildIdx = idx * 2 + 1;\r\n    let swapIdx = -1;\r\n    while (firstChildIdx <= endIdx) {\r\n      let secondChildIdx = idx * 2 + 2 <= endIdx ? idx * 2 + 2 : -1;\r\n      if (\r\n        secondChildIdx !== -1 &&\r\n        heap[secondChildIdx][this.property] < heap[firstChildIdx][this.property]\r\n      ) {\r\n        swapIdx = secondChildIdx;\r\n      } else {\r\n        swapIdx = firstChildIdx;\r\n      }\r\n      if (heap[swapIdx][this.property] < heap[idx][this.property]) {\r\n        this.swap(swapIdx, idx, heap);\r\n      } else {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  insert(value) {\r\n    this.heap.push(value);\r\n    this.siftUp(this.heap.length - 1, this.heap);\r\n  }\r\n\r\n  remove() {\r\n    this.swap(0, this.heap.length - 1, this.heap);\r\n    let value = this.heap.pop();\r\n    this.siftDown(0, this.heap.length - 1, this.heap);\r\n    return value;\r\n  }\r\n\r\n  siftUp(idx, heap) {\r\n    let parentIdx = parseInt((idx - 1) / 2);\r\n    while (\r\n      idx > 0 &&\r\n      heap[parentIdx][this.property] > heap[idx][this.property]\r\n    ) {\r\n      this.swap(idx, parentIdx, heap);\r\n      idx = parentIdx;\r\n      parentIdx = parseInt((idx - 1) / 2);\r\n    }\r\n  }\r\n\r\n  swap(i, j, array) {\r\n    let temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n  }\r\n}\r\n","import { PriorityQueue } from \"./priority-queue\";\r\n\r\nexport function aStar(grid, sourceNode, finishNode) {\r\n  let visitedNodes = [];\r\n  sourceNode.distance = 0;\r\n  sourceNode.fScore = getScore(sourceNode, finishNode);\r\n  sourceNode.direction = \"up\";\r\n  let priorityQueue = new PriorityQueue(\"fScore\");\r\n  priorityQueue.insert(sourceNode);\r\n  while (!priorityQueue.isEmpty()) {\r\n    let node = priorityQueue.get();\r\n\r\n    if(node.isWall) continue\r\n    node.isVisited = true;\r\n    visitedNodes.push(node);\r\n\r\n    if (node === finishNode) return visitedNodes;\r\n    updateUnvisitedNeighbour(node, grid, finishNode, priorityQueue);\r\n  }\r\n  return visitedNodes;\r\n}\r\n\r\nfunction updateUnvisitedNeighbour(node, grid, finishNode, priorityQueue) {\r\n  let unvisitedNeighbour = getUnvisitedNeighbours(node, grid);\r\n  for (const neighbor of unvisitedNeighbour) {\r\n    let distance = getScore(node, neighbor);\r\n    if (distance < neighbor.distance) {\r\n      neighbor.previousNode = node;\r\n      neighbor.distance = distance;\r\n      neighbor.fScore = distance + getScore(neighbor, finishNode);\r\n      if (!neighbor.isVisited) {\r\n        priorityQueue.insert(neighbor);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction getScore(nodeOne, nodeTwo) {\r\n  const x1 = nodeOne.row;\r\n  const y1 = nodeOne.col;\r\n  const x2 = nodeTwo.row;\r\n  const y2 = nodeTwo.col;\r\n\r\n  return Math.abs(x1 - x2) + Math.abs(y1 - y2);\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  let neighbors = [];\r\n  const { row, col } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors;\r\n}\r\n","import { PriorityQueue } from \"./priority-queue\";\r\n\r\nexport function bestFirstSearch(grid, sourceNode, finishNode) {\r\n  console.log(\"best first search\");\r\n  let visitedNodes = [];\r\n  sourceNode.distance = 0;\r\n  let priorityQueue = new PriorityQueue(\"distance\");\r\n\r\n  priorityQueue.insert(sourceNode);\r\n\r\n  while (!priorityQueue.isEmpty()) {\r\n    const node = priorityQueue.get();\r\n    if (node.isWall) continue;\r\n    node.isVisited = true;\r\n    visitedNodes.push(node);\r\n\r\n    if (node === finishNode) return visitedNodes;\r\n\r\n    let unvisitedNodes = updateUnvisitedNeighbour(node, grid);\r\n\r\n    for (let neighbor of unvisitedNodes) {\r\n      if (!neighbor.isVisited) {\r\n        neighbor.isVisited = true;\r\n        priorityQueue.insert(neighbor);\r\n      }\r\n    }\r\n  }\r\n\r\n  return visitedNodes;\r\n}\r\n\r\nfunction updateUnvisitedNeighbour(node, grid) {\r\n  let unvisitedNeighbour = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbour) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n\r\n  return unvisitedNeighbour;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  let neighbors = [];\r\n  const { row, col } = node;\r\n\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n","const createNode = (col, row) => {\r\n    return {\r\n      row,\r\n      col,\r\n      isStart: false,\r\n      isFinish: false,\r\n      direction: null,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      fScore: Infinity,\r\n    };\r\n  };\r\n  \r\n  export const getInitialGrid=(boardHeight,boardWidth)  =>{\r\n    const grid = [];\r\n    for (let row = 0; row < boardHeight; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < boardWidth; col++) {\r\n        currentRow.push(createNode(col, row));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n\r\n  export const resetGrid=(ref,nodes,sourceNode,finishNode,removeWall)=>{\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        let node = nodes[i];\r\n        if(!removeWall && node.isWall){\r\n          continue\r\n        }\r\n        let dom=ref[`node-${node.row}-${node.col}`]\r\n        if(node===sourceNode){\r\n          node.isStart=true\r\n          dom.className=\"node node-start\"\r\n        }\r\n        else if(node===finishNode){\r\n          node.isFinish=true\r\n         \r\n          dom.className=\"node node-finish\"\r\n        }\r\n        else{\r\n          dom.className=\"node\"\r\n        }\r\n         \r\n          node.isVisited=false\r\n          \r\n        }\r\n        \r\n\r\n  }\r\n  ","import React, { Component } from \"react\";\r\nimport { Node } from \"../Node\";\r\nimport { NavBar } from \"../Navbar\";\r\nimport { recursiveDivision } from \"../maze-algorithms/recursive-division\";\r\nimport {recursiveDivisionVertical} from \"../maze-algorithms/recursive-division-vertical\";\r\nimport {recursiveDivisionHorizontal} from '../maze-algorithms/recurisive-division-horizontal';\r\nimport { bfs } from \"../algorithms/bfs\";\r\nimport { depthFirstSearch } from \"../algorithms/depth-first-search\";\r\nimport { dijsktras } from \"../algorithms/dijsktras\";\r\nimport { aStar } from \"../algorithms/a-star\";\r\nimport { bestFirstSearch } from \"../algorithms/best-first-search\";\r\nimport { getShortestPathNodes } from \"../algorithms/shortest-path\";\r\nimport {getInitialGrid,resetGrid} from '../create-grid'\r\nimport \"./Pathvisualizer.css\";\r\n\r\n\r\nexport class Pathvisualizer extends Component {\r\n  constructor() {\r\n    super();\r\n    this.state = {\r\n      grid: [],\r\n      START_NODE_ROW: 5,\r\n      START_NODE_COL: 5,\r\n      FINISH_NODE_ROW: 10,\r\n      FINISH_NODE_COL: 10,\r\n      animationDelay:10,\r\n      dragStart: false,\r\n      dragTarget: false,\r\n      mouseIsPressed: false,\r\n      delays:{slow:20,average:10,fast:5},\r\n      algorithmHeading: \"Pick An Algorithm\",\r\n      algorithm: \"\",\r\n      mazeAlgorithms: [\"Recursive Division\",\"Recursive Division (Vertical)\",\"Recursive Division (Horizontal)\"],\r\n      algorithms: [\r\n        \"Dijsktras\",\r\n        \"Breadth First Search\",\r\n        \"Best First Search\",\r\n        \"Depth First Search\",\r\n        \"A* Algorithm\",\r\n      ],\r\n      boardHeight:null,\r\n      boardWidth:null\r\n    };\r\n    this.visualize = this.visualize.bind(this);\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\r\n    this.handleMouseUp = this.handleMouseUp.bind(this);\r\n    this.handleAlgo = this.handleAlgo.bind(this);\r\n    this.generateMaze = this.generateMaze.bind(this);\r\n    this.reset=this.reset.bind(this)\r\n    this.animateTraversal=this.animateTraversal.bind(this)\r\n    this.animateMaze=this.animateMaze.bind(this)\r\n    this.changespeed=this.changespeed.bind(this)\r\n  }\r\n  componentDidMount() {\r\n    const navbarHeight=this.navRef.clientHeight;\r\n    const headingHeight=this.headingRef.clientHeight\r\n    let boardHeight=Math.floor((document.documentElement.clientHeight-navbarHeight-headingHeight)/30)\r\n    let boardWidth=Math.floor(document.documentElement.clientWidth/25)\r\n    this.setState({boardHeight,boardWidth})\r\n    const grid = getInitialGrid(boardHeight,boardWidth);\r\n    this.setState({ grid });\r\n  }\r\n  \r\n  changespeed(delay){\r\n    const {delays}=this.state\r\n    this.setState({animationDelay:delays[delay]})\r\n  }\r\n\r\n\r\n  reset(removeWall){\r\n    const { grid , \r\n      START_NODE_ROW,\r\n      START_NODE_COL,\r\n      FINISH_NODE_ROW,\r\n      FINISH_NODE_COL,\r\n    } = this.state;\r\n    const start = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finish = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let nodes=getAllUnvisitedNodes(grid)\r\n    resetGrid(this,nodes,start,finish,removeWall)\r\n    this.setState({algorithmHeading:\"Pick An Algorithm\"})\r\n  }\r\n\r\n  generateMaze(algorithm) {\r\n    const { grid , \r\n      START_NODE_ROW,\r\n      START_NODE_COL,\r\n      FINISH_NODE_ROW,\r\n      FINISH_NODE_COL,\r\n      boardHeight,\r\n      boardWidth\r\n    } = this.state;\r\n    const start = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finish = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    let visitedNodes=[]\r\n   \r\n    let nodes=getAllUnvisitedNodes(grid)\r\n    switch (algorithm) {\r\n      case \"Recursive Division\": {\r\n        this.createBoundary(grid,boardHeight,boardWidth,visitedNodes)\r\n       recursiveDivision(\r\n          nodes,\r\n          false,\r\n          start,\r\n          finish,\r\n          2,\r\n        boardHeight-3,\r\n          2,\r\n          boardWidth-3,\r\n          visitedNodes\r\n        );\r\n      \r\n      \r\n        break;\r\n      }\r\n      case \"Recursive Division (Vertical)\":{\r\n        this.createBoundary(grid,boardHeight,boardWidth,visitedNodes)\r\n        recursiveDivisionVertical(  nodes,\r\n          false,\r\n          start,\r\n          finish,\r\n          2,\r\n        boardHeight-3,\r\n          2,\r\n          boardWidth-3,\r\n          visitedNodes)\r\n        break\r\n      }\r\n      case \"Recursive Division (Horizontal)\":{\r\n        this.createBoundary(grid,boardHeight,boardWidth,visitedNodes)\r\n        recursiveDivisionHorizontal(  nodes,\r\n          true,\r\n          start,\r\n          finish,\r\n          2,\r\n        boardHeight-3,\r\n          2,\r\n          boardWidth-3,\r\n          visitedNodes)\r\n        break\r\n      }\r\n      default:\r\n        this.reset()\r\n    }\r\n\r\n    if(visitedNodes && visitedNodes.length){\r\n          \r\n      this.animateMaze(visitedNodes);\r\n    }\r\n  }\r\n\r\n  createBoundary(grid,boardHeight,boardWidth,visitedNodes){\r\n    for(let row=0;row<boardHeight;row++){\r\n      for(let col=0;col<boardWidth;col++){\r\n        if(row===0 || row===boardHeight-1 || col===0 || col===boardWidth-1){\r\n          visitedNodes.push(grid[row][col])\r\n        }\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  animateMaze(visitedNodes) {\r\n    for (let i = 0; i < visitedNodes.length; i++) {\r\n      setTimeout(() => {\r\n        let node = visitedNodes[i];\r\n        node.isWall=true\r\n        let dom=this[`node-${node.row}-${node.col}`]\r\n        dom.className=\"node node-wall\"\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  handleAlgo(algorithm) {\r\n    switch (algorithm) {\r\n      case \"Breadth First Search\": {\r\n        this.setState({ algorithm: \"Breadth First Search\" });\r\n        this.setState({ algorithmHeading: \"Breadth First Search Algorithm\" });\r\n        break;\r\n      }\r\n      case \"Dijsktras\": {\r\n        this.setState({ algorithm: \"Dijsktras\" });\r\n        this.setState({ algorithmHeading: \"Dijsktras Algorithm\" });\r\n        break;\r\n      }\r\n      case \"Best First Search\": {\r\n        this.setState({ algorithm: \"Best First Search\" });\r\n        this.setState({ algorithmHeading: \"Best First Search Algorithm\" });\r\n        break;\r\n      }\r\n\r\n      case \"Depth First Search\": {\r\n        this.setState({ algorithm: \"Depth First Search\" });\r\n        this.setState({ algorithmHeading: \"Depth First Search Algorithm\" });\r\n        break;\r\n      }\r\n      case \"A* Algorithm\": {\r\n        this.setState({ algorithm: \"A* Algorithm\" });\r\n        this.setState({ algorithmHeading: \"A* Algorithm\" });\r\n        break;\r\n      }\r\n      default:\r\n        this.setState({ algorithm: \"\" });\r\n    }\r\n  }\r\n\r\n  animateWall(row,col){\r\n    let dom=this[`node-${row}-${col}`]\r\n    dom.className=\"node node-wall\"\r\n  }\r\n  \r\n  handleMouseDown(row, col) {\r\n    const {\r\n      grid,\r\n      START_NODE_ROW,\r\n      START_NODE_COL,\r\n      FINISH_NODE_ROW,\r\n      FINISH_NODE_COL,\r\n    } = this.state;\r\n    if (row === START_NODE_ROW && col === START_NODE_COL) {\r\n      this.setState({ dragStart: true});\r\n    } else if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\r\n      this.setState({ dragTarget: true });\r\n    } else {\r\n      grid[row][col].isWall=!grid[row][col].isWall\r\n      this.animateWall(row,col)\r\n      this.setState({mouseIsPressed:true})\r\n    }\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    const { grid,dragStart, dragTarget, mouseIsPressed } = this.state;\r\n    if (dragStart) {\r\n      this.setState({ START_NODE_ROW: row, START_NODE_COL: col });\r\n    } \r\n    else if (dragTarget) {\r\n      this.setState({ FINISH_NODE_ROW: row, FINISH_NODE_COL: col });\r\n    } \r\n    else if (mouseIsPressed ) {\r\n      grid[row][col].isWall=!grid[row][col].isWall\r\n      this.animateWall(row,col)\r\n      this.setState({mouseIsPressed:true})\r\n    }\r\n  }\r\n\r\n  handleMouseOut(){\r\n    this.setState({\r\n      mouseIsPressed: false,\r\n    });\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({\r\n      mouseIsPressed: false,\r\n      dragStart: false,\r\n      dragTarget: false,\r\n    });\r\n  }\r\n\r\n  animateTraversal(visitedNodesInorder, shortestPathNodes) {\r\n    const {animationDelay}=this.state\r\n    for (let i = 0; i <= visitedNodesInorder.length; i++) {\r\n      if (i === visitedNodesInorder.length) {\r\n        if(!shortestPathNodes.length){\r\n          return\r\n        }\r\n        setTimeout(() => {\r\n          this.animateShortestPath(shortestPathNodes);\r\n        }, animationDelay * i);\r\n\r\n        return;\r\n      }\r\n\r\n      setTimeout(() => {\r\n        let node = visitedNodesInorder[i];\r\n        let dom=this[`node-${node.row}-${node.col}`]\r\n        dom.className=\"node node-visited\"\r\n      }, animationDelay * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(shortestPathNodes) {\r\n    const {animationDelay}=this.state\r\n    for (let i = 0; i < shortestPathNodes.length; i++) {\r\n      setTimeout(() => {\r\n        let node = shortestPathNodes[i];\r\n        let dom=this[`node-${node.row}-${node.col}`]\r\n        dom.className=\"node shortest-path-node\"\r\n      }, animationDelay*5 * i);\r\n    }\r\n  }\r\n\r\n  traverseAlgorithms(algorithm) {\r\n    let visitedNodesInorder = [];\r\n    const {\r\n      grid,\r\n      START_NODE_ROW,\r\n      START_NODE_COL,\r\n      FINISH_NODE_ROW,\r\n      FINISH_NODE_COL,\r\n    } = this.state;\r\n    const start = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finish = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n\r\n    switch (algorithm) {\r\n      case \"Dijsktras\": {\r\n        visitedNodesInorder = dijsktras(grid, start, finish);\r\n        break;\r\n      }\r\n      case \"Breadth First Search\": {\r\n        visitedNodesInorder = bfs(grid, start, finish);\r\n        break;\r\n      }\r\n\r\n      case \"Best First Search\": {\r\n        visitedNodesInorder = bestFirstSearch(grid, start, finish);\r\n        break;\r\n      }\r\n\r\n      case \"Depth First Search\": {\r\n        visitedNodesInorder = depthFirstSearch(grid, start, finish);\r\n        break;\r\n      }\r\n      case \"A* Algorithm\": {\r\n        visitedNodesInorder = aStar(grid, start, finish);\r\n        break;\r\n      }\r\n      default:\r\n        this.setState({ algorithmHeading: \"Pick An Algorithm\" });\r\n    }\r\n    const shortestPathNodes = getShortestPathNodes(finish);\r\n\r\n    return { visitedNodesInorder, shortestPathNodes };\r\n  }\r\n\r\n  \r\n\r\n  visualize() {\r\n    const { algorithm } = this.state;\r\n    if(algorithm!==\"\"){\r\n      this.reset(false)\r\n      const { visitedNodesInorder, shortestPathNodes } = this.traverseAlgorithms(\r\n        algorithm\r\n      );\r\n    \r\n        this.animateTraversal(visitedNodesInorder, shortestPathNodes);\r\n    }\r\n   \r\n    \r\n  }\r\n  render() {\r\n    const { grid, mouseIsPressed,animationDelay } = this.state;\r\n    return (\r\n      <>\r\n        <NavBar\r\n          navRef={element=>{this.navRef=element}}\r\n          reset={this.reset}\r\n          onSelect={this.handleAlgo}\r\n          selectMaze={this.generateMaze}\r\n          visualize={this.visualize}\r\n          changespeed={this.changespeed}\r\n          animationDelay={animationDelay}\r\n          delays={this.state.delays}\r\n          algorithms={this.state.algorithms}\r\n          mazeAlgorithms={this.state.mazeAlgorithms}\r\n          heading={this.state.algorithmHeading}\r\n        ></NavBar>\r\n        <h3 ref={element=>{this.headingRef=element}} className=\"text-center\">{this.state.algorithmHeading}</h3>\r\n        <table className={\"board\"}>\r\n          <tbody>\r\n            {grid.map((row, rowIdx) => {\r\n              return (\r\n                <tr key={rowIdx}>\r\n                  {row.map((node, nodeIdx) => {\r\n                    const { col, row, isWall } = node;\r\n                    return (\r\n                      <Node\r\n                        key={nodeIdx}\r\n                        setRef={(node)=>{ this[`node-${row}-${col}`]=node}}\r\n                        isStart={\r\n                          row === this.state.START_NODE_ROW &&\r\n                          col === this.state.START_NODE_COL\r\n                        }\r\n                        isFinish={\r\n                          row === this.state.FINISH_NODE_ROW &&\r\n                          col === this.state.FINISH_NODE_COL\r\n                        }\r\n                        isWall={isWall}\r\n                        mouseIsPressed={mouseIsPressed}\r\n                        onMouseDown={(row, col) =>\r\n                          this.handleMouseDown(row, col)\r\n                        }\r\n                        onMouseEnter={(row, col) =>\r\n                          this.handleMouseEnter(row, col)\r\n                        }\r\n                        onMouseUp={() => {\r\n                          this.handleMouseUp();\r\n                        }}\r\n                        onMouseOut={()=>{\r\n                          this.handleMouseOut()\r\n                        }}\r\n                        col={col}\r\n                        row={row}\r\n                      ></Node>\r\n                    );\r\n                  })}\r\n                </tr>\r\n              );\r\n            })}\r\n          </tbody>\r\n        </table>\r\n      </>\r\n    );\r\n  }\r\n}\r\n\r\n\r\nfunction getAllUnvisitedNodes(grid) {\r\n  let nodes = [];\r\n  for (let row of grid) {\r\n    for (let node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n\r\n  return nodes;\r\n}\r\n","export function getShortestPathNodes(finishNode) {\r\n  let currentNode = finishNode;\r\n  let pathNodes = [];\r\n  while (currentNode != null) {\r\n    pathNodes.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return pathNodes;\r\n}\r\n","import React from \"react\";\r\nimport \"./App.css\";\r\n\r\nimport { Pathvisualizer } from \"./components/Pathvisualizer\";\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\">\r\n      <Pathvisualizer></Pathvisualizer>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\r\nimport ReactDOM from \"react-dom\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\nimport * as serviceWorker from \"./serviceWorker\";\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById(\"root\")\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}